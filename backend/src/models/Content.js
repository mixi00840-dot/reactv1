const mongoose = require('mongoose');

/**
 * Content Model - Core model for Videos, Stories, Posts
 * Supports TikTok-style short videos with full metadata
 */
const contentSchema = new mongoose.Schema({
  // Content identification
  contentId: {
    type: String,
    unique: true,
    required: true,
    index: true
  },
  
  // Creator information
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  // Content type and status
  type: {
    type: String,
    enum: ['video', 'story', 'post', 'image', 'carousel'],
    required: true,
    index: true
  },
  
  status: {
    type: String,
    enum: ['uploading', 'processing', 'transcoding', 'ready', 'failed', 'deleted', 'archived'],
    default: 'uploading',
    index: true
  },
  
  visibility: {
    type: String,
    enum: ['public', 'private', 'followers', 'friends', 'unlisted'],
    default: 'public',
    index: true
  },
  
  // Content metadata
  caption: {
    type: String,
    maxlength: 2200,
    trim: true
  },
  
  description: {
    type: String,
    maxlength: 5000
  },
  
  // Tags and mentions
  tags: [{
    type: String,
    lowercase: true,
    trim: true,
    index: true
  }],
  
  hashtags: [{
    tag: String,
    normalizedTag: String // lowercase, no #
  }],
  
  mentions: [{
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    username: String,
    position: Number
  }],
  
  // Location data
  location: {
    name: String,
    latitude: Number,
    longitude: Number,
    placeId: String,
    city: String,
    country: String,
    countryCode: String
  },
  
  // Sound/Music association
  soundId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Sound',
    index: true
  },
  
  originalSound: {
    type: Boolean,
    default: false
  },
  
  // Media files (master and processed versions)
  media: {
    // Master upload
    masterFile: {
      url: String,
      key: String, // S3 key
      size: Number, // bytes
      mimeType: String,
      uploadedAt: Date
    },
    
    // Video-specific
    duration: Number, // seconds
    width: Number,
    height: Number,
    aspectRatio: String, // '9:16', '16:9', '1:1'
    fps: Number,
    bitrate: Number,
    codec: String,
    hasAudio: Boolean,
    
    // Thumbnails
    thumbnails: [{
      url: String,
      key: String,
      width: Number,
      height: Number,
      timeOffset: Number, // second in video
      isDefault: Boolean
    }],
    
    // Animated preview (GIF/short clip)
    animatedPreview: {
      url: String,
      key: String,
      duration: Number,
      size: Number
    },
    
    // Transcoded versions
    versions: [{
      quality: String, // '1080p', '720p', '480p', '360p', '240p'
      url: String,
      key: String,
      size: Number,
      bitrate: Number,
      width: Number,
      height: Number,
      format: String, // 'mp4', 'hls', 'dash'
      hlsManifest: String, // URL to .m3u8
      dashManifest: String // URL to .mpd
    }],
    
    // Captions/Subtitles
    captions: [{
      language: String,
      url: String, // VTT file
      key: String,
      autoGenerated: Boolean,
      confidence: Number
    }]
  },
  
  // Story-specific fields
  storyMetadata: {
    expiresAt: Date,
    isHighlight: Boolean,
    highlightTitle: String,
    viewersList: [{
      userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      viewedAt: Date,
      viewDuration: Number // seconds
    }],
    allowReplies: {
      type: Boolean,
      default: true
    },
    replies: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Content'
    }]
  },
  
  // Post-specific fields (multi-image carousel)
  postMetadata: {
    imageUrls: [{
      url: String,
      key: String,
      width: Number,
      height: Number,
      order: Number
    }],
    linkPreview: {
      url: String,
      title: String,
      description: String,
      imageUrl: String
    }
  },
  
  // Interaction settings
  settings: {
    allowComments: {
      type: Boolean,
      default: true
    },
    allowDuet: {
      type: Boolean,
      default: true
    },
    allowStitch: {
      type: Boolean,
      default: true
    },
    allowDownload: {
      type: Boolean,
      default: true
    },
    allowSharing: {
      type: Boolean,
      default: true
    },
    showLikeCount: {
      type: Boolean,
      default: true
    },
    showViewCount: {
      type: Boolean,
      default: true
    },
    ageRestricted: {
      type: Boolean,
      default: false
    },
    disableAI: {
      type: Boolean,
      default: false
    }
  },
  
  // Duet/Stitch references
  originalContentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Content'
  },
  
  isDuet: {
    type: Boolean,
    default: false
  },
  
  isStitch: {
    type: Boolean,
    default: false
  },
  
  // Metrics aggregation (cached from ContentMetrics)
  metrics: {
    views: {
      type: Number,
      default: 0,
      index: true
    },
    uniqueViews: {
      type: Number,
      default: 0
    },
    watchTime: {
      type: Number,
      default: 0
    },
    avgWatchTime: {
      type: Number,
      default: 0
    },
    completionRate: {
      type: Number,
      default: 0
    },
    likes: {
      type: Number,
      default: 0,
      index: true
    },
    comments: {
      type: Number,
      default: 0
    },
    shares: {
      type: Number,
      default: 0
    },
    saves: {
      type: Number,
      default: 0
    },
    duets: {
      type: Number,
      default: 0
    },
    stitches: {
      type: Number,
      default: 0
    },
    downloads: {
      type: Number,
      default: 0
    },
    engagementScore: {
      type: Number,
      default: 0,
      index: true
    },
    viralityScore: {
      type: Number,
      default: 0
    }
  },
  
  // AI-generated metadata
  aiMetadata: {
    // Auto-tagging
    detectedObjects: [{
      label: String,
      confidence: Number,
      boundingBox: {
        x: Number,
        y: Number,
        width: Number,
        height: Number
      }
    }],
    
    detectedScenes: [{
      label: String,
      confidence: Number,
      timeRange: {
        start: Number,
        end: Number
      }
    }],
    
    // OCR text extraction
    extractedText: [{
      text: String,
      confidence: Number,
      language: String,
      position: {
        x: Number,
        y: Number
      }
    }],
    
    // Auto-generated tags
    suggestedTags: [{
      tag: String,
      confidence: Number
    }],
    
    // Topic classification
    topics: [{
      topic: String,
      category: String,
      confidence: Number
    }],
    
    // Dominant colors (for thumbnails/UI)
    dominantColors: [String],
    
    // Content embeddings for recommendation
    embeddings: {
      visual: [Number], // 512-dim vector
      audio: [Number], // 256-dim vector
      text: [Number], // 384-dim vector
      combined: [Number] // 768-dim vector
    },
    
    lastProcessedAt: Date
  },
  
  // Moderation results
  moderation: {
    status: {
      type: String,
      enum: ['pending', 'approved', 'rejected', 'flagged', 'appealed', 'reinstated'],
      default: 'pending',
      index: true
    },
    
    autoModeration: {
      processed: {
        type: Boolean,
        default: false
      },
      scores: {
        nsfw: Number, // 0-1
        violence: Number,
        gore: Number,
        hate: Number,
        harassment: Number,
        selfHarm: Number,
        sexual: Number,
        spam: Number,
        overall: Number
      },
      labels: [String],
      decision: String, // 'approve', 'review', 'block'
      processedAt: Date
    },
    
    manualReview: {
      required: {
        type: Boolean,
        default: false
      },
      reviewedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      reviewedAt: Date,
      decision: String,
      notes: String
    },
    
    flags: [{
      reason: String,
      flaggedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      flaggedAt: Date,
      status: String
    }],
    
    appeals: [{
      reason: String,
      submittedAt: Date,
      reviewedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      reviewedAt: Date,
      decision: String,
      response: String
    }]
  },
  
  // Monetization
  monetization: {
    isPromoted: {
      type: Boolean,
      default: false
    },
    promotionBudget: Number,
    hasProductLinks: {
      type: Boolean,
      default: false
    },
    linkedProducts: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Product'
    }],
    isSponsored: {
      type: Boolean,
      default: false
    },
    sponsorDisclosure: String
  },
  
  // Featured/Editorial
  featured: {
    isFeatured: {
      type: Boolean,
      default: false,
      index: true
    },
    featuredAt: Date,
    featuredBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    featuredUntil: Date,
    featuredCategory: String,
    featuredPosition: Number
  },
  
  // Processing state
  processing: {
    uploadProgress: {
      type: Number,
      default: 0,
      min: 0,
      max: 100
    },
    transcodeProgress: {
      type: Number,
      default: 0
    },
    currentStep: String,
    lastError: String,
    retryCount: {
      type: Number,
      default: 0
    },
    processingStartedAt: Date,
    processingCompletedAt: Date
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
contentSchema.index({ userId: 1, createdAt: -1 });
contentSchema.index({ type: 1, status: 1, createdAt: -1 });
contentSchema.index({ 'metrics.engagementScore': -1, createdAt: -1 });
contentSchema.index({ 'metrics.views': -1, createdAt: -1 });
contentSchema.index({ tags: 1, createdAt: -1 });
contentSchema.index({ soundId: 1, createdAt: -1 });
contentSchema.index({ 'location.countryCode': 1, createdAt: -1 });
contentSchema.index({ 'featured.isFeatured': 1, 'featured.featuredAt': -1 });
contentSchema.index({ 'moderation.status': 1, createdAt: -1 });

// Story expiration index (TTL)
contentSchema.index({ 'storyMetadata.expiresAt': 1 }, { 
  expireAfterSeconds: 0,
  partialFilterExpression: { 
    type: 'story',
    'storyMetadata.isHighlight': false 
  }
});

// Virtual: is content expired (for stories)
contentSchema.virtual('isExpired').get(function() {
  if (this.type === 'story' && this.storyMetadata?.expiresAt) {
    return new Date() > this.storyMetadata.expiresAt;
  }
  return false;
});

// Virtual: engagement rate
contentSchema.virtual('engagementRate').get(function() {
  if (this.metrics.views === 0) return 0;
  const totalEngagement = this.metrics.likes + this.metrics.comments + 
                          this.metrics.shares + this.metrics.saves;
  return (totalEngagement / this.metrics.views) * 100;
});

// Virtual: stream URLs for video playback
contentSchema.virtual('streamUrls').get(function() {
  if (this.type !== 'video') return null;
  
  const hls = this.media.versions.find(v => v.format === 'hls');
  const dash = this.media.versions.find(v => v.format === 'dash');
  const mp4 = this.media.versions.find(v => v.format === 'mp4');
  
  return {
    hls: hls?.hlsManifest || null,
    dash: dash?.dashManifest || null,
    mp4: mp4?.url || null,
    thumbnails: this.media.thumbnails.map(t => t.url),
    captions: this.media.captions.map(c => ({
      language: c.language,
      url: c.url,
      autoGenerated: c.autoGenerated
    }))
  };
});

// Pre-save: generate contentId if not exists
contentSchema.pre('save', function(next) {
  if (!this.contentId) {
    this.contentId = `${this.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // Normalize hashtags
  if (this.hashtags && this.hashtags.length > 0) {
    this.hashtags = this.hashtags.map(h => ({
      tag: h.tag,
      normalizedTag: h.tag.toLowerCase().replace(/^#/, '')
    }));
  }
  
  // Set story expiration if not set
  if (this.type === 'story' && !this.storyMetadata?.expiresAt) {
    if (!this.storyMetadata) this.storyMetadata = {};
    this.storyMetadata.expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
  }
  
  next();
});

// Method: mark content as ready after processing
contentSchema.methods.markAsReady = async function() {
  this.status = 'ready';
  this.processing.transcodeProgress = 100;
  this.processing.processingCompletedAt = new Date();
  this.processing.currentStep = 'completed';
  return this.save();
};

// Method: mark processing as failed
contentSchema.methods.markAsFailed = async function(error) {
  this.status = 'failed';
  this.processing.lastError = error;
  this.processing.retryCount += 1;
  return this.save();
};

// Method: update metrics from ContentMetrics model
contentSchema.methods.updateMetrics = async function(metricsData) {
  Object.assign(this.metrics, metricsData);
  await this.save();
};

// Method: add viewer to story
contentSchema.methods.addStoryViewer = async function(userId, viewDuration) {
  if (this.type !== 'story') return;
  
  const existingViewer = this.storyMetadata.viewersList.find(
    v => v.userId.toString() === userId.toString()
  );
  
  if (!existingViewer) {
    this.storyMetadata.viewersList.push({
      userId,
      viewedAt: new Date(),
      viewDuration
    });
    await this.save();
  }
};

// Method: check if content is available
contentSchema.methods.isAvailable = function() {
  if (this.status !== 'ready') return false;
  if (this.visibility === 'private') return false;
  if (this.moderation.status === 'rejected' || this.moderation.status === 'flagged') return false;
  if (this.type === 'story' && this.isExpired) return false;
  return true;
};

// Static: Get content feed with filters
contentSchema.statics.getFeed = async function(filters = {}, options = {}) {
  const {
    userId,
    type,
    visibility = 'public',
    following = false,
    location,
    tags,
    soundId,
    limit = 20,
    skip = 0,
    sortBy = 'createdAt',
    sortOrder = 'desc'
  } = options;
  
  const query = {
    status: 'ready',
    'moderation.status': 'approved'
  };
  
  if (type) query.type = type;
  if (visibility) query.visibility = visibility;
  if (soundId) query.soundId = soundId;
  if (location) query['location.countryCode'] = location;
  if (tags && tags.length > 0) query.tags = { $in: tags };
  
  // Following feed
  if (following && userId) {
    const User = mongoose.model('User');
    const user = await User.findById(userId).select('following');
    query.userId = { $in: user.following };
  }
  
  const sort = {};
  sort[sortBy] = sortOrder === 'desc' ? -1 : 1;
  
  return this.find(query)
    .sort(sort)
    .skip(skip)
    .limit(limit)
    .populate('userId', 'username fullName profilePicture verified')
    .populate('soundId', 'title artist duration')
    .lean();
};

// Static: Get trending content
contentSchema.statics.getTrending = async function(options = {}) {
  const {
    timeWindow = 24, // hours
    type,
    location,
    limit = 20
  } = options;
  
  const since = new Date(Date.now() - timeWindow * 60 * 60 * 1000);
  
  const query = {
    status: 'ready',
    'moderation.status': 'approved',
    createdAt: { $gte: since }
  };
  
  if (type) query.type = type;
  if (location) query['location.countryCode'] = location;
  
  return this.find(query)
    .sort({ 'metrics.engagementScore': -1, 'metrics.viralityScore': -1 })
    .limit(limit)
    .populate('userId', 'username fullName profilePicture verified')
    .populate('soundId', 'title artist')
    .lean();
};

// Static: Search content
contentSchema.statics.searchContent = async function(searchTerm, options = {}) {
  const {
    type,
    limit = 20,
    skip = 0
  } = options;
  
  const query = {
    status: 'ready',
    'moderation.status': 'approved',
    $or: [
      { caption: { $regex: searchTerm, $options: 'i' } },
      { description: { $regex: searchTerm, $options: 'i' } },
      { tags: { $regex: searchTerm, $options: 'i' } },
      { 'hashtags.normalizedTag': { $regex: searchTerm, $options: 'i' } }
    ]
  };
  
  if (type) query.type = type;
  
  return this.find(query)
    .sort({ 'metrics.views': -1, createdAt: -1 })
    .skip(skip)
    .limit(limit)
    .populate('userId', 'username fullName profilePicture verified')
    .lean();
};

const Content = mongoose.model('Content', contentSchema);

module.exports = Content;
